import UIKit
/*:
 # 메모리 릭
 ## 특히 클로저만 살펴보자
 */


//TestClass가 aBlock을 가지고 있고, aBlock이 클로저에서 self를 캡쳐한 상황이다. 그래서 init함수가 종료되어도 사라지지 않음.. 강함참조 발생하는 경우
class TestClass{
    var aBlock: (()->())? = nil
    let aConstant = 5
    
    init(){
        print("init")
        aBlock = {
            print(self.aConstant)
        }
    }
    deinit {
        print("deinit")
    }
}

var testClass: TestClass? = TestClass()
testClass = nil


//강한참조 발생안함
//이경우는 위의 경우와 다르다! 일단 클래스가 aBlock이 클래스에 저장되어 있지 않음. init함수가 불리울때 처음으로 생성후 함수가 종료되자마자 사라짐. 클로져를 locally하게 사용하면 문제되지 않음.. 더 자세한 예시는 밑!
class TestClass2 {
    let aConstant = 5
    
    init() {
        print("init")
        let aBlock = {
            print(self.aConstant)
        }
    }
    deinit {
        print("deinit")
    }
}
var testClass2: TestClass2? = TestClass2()
testClass2 = nil


//우리가 흔히 볼수 있는 예시이다.
// 블록 자체는 블록 내부에서 self, 즉 TestClass 객체를 강하게 참조하지만 Closure자체는 메소드 지역안에 존재하기 때문에 메소드가 return되면 메모리에서 해제됩니다.
class TestClass3{
    let aConstant = 5
    
    init(){
        print("init")
    }
    deinit {
        print("deinit TestClass3")
    }
    func doSomething(){
        UIView.animate(withDuration: 5){
            let aConstant = self.aConstant
            
            // fancy animation ... .
        }
    }
}

var testClass3: TestClass3? = TestClass3()
testClass3?.doSomething()
testClass3 = nil


//클로저에 관한 메모리릭은 제일 이해가지 않았던 부분이다. 하지만 https://baked-corn.tistory.com/30 의 블로그를 보고 이해 할수 있었다.



/*
 -> 인프런 강의 관려
 일반적으로 동영상을 재생하면
 일단 원본을 메모리에 복사-> 데이터 메모리 영역에 복사. 메모리에서 실행. 종료시 메모리에서 사라짐.

 이동을 하면, 이동공간에 복사 원본 삭제 방식임.

 데이터 메모리: 메모리에 지정해 놓은 영역
 실행시 데이터 메모리에 데이터가 생겨나고 사용되고 사라짐

 기계어: 컴퓨터가 받아들여 실행할 수 있는 언어
 프로그램: 원하는 기능을 가지는 명령의 집합( 원하는 기능의 기계어의 집합)
 프로그래밍: 프로그램을 만드는 작업
     1. 기계어를 직접 만드는 작업(과거)
     2. 프로그래밍 언어를 통해 프로그램을 만드는 작업(현재)

 폰노이만의 컴퓨터 구조의 핵심이 되는 내용과 프로그램 메모리에 대해 알아보자
 폰노이만 컴퓨터 구조: 컴퓨터의 기본원리 + 폰노이만이 만든 컴퓨터 원리 -> 프로그램을 메모리에서 변경해서 실행할 수 있다는 것(핵심)

 프로그램 메모리: 코드를 실행하기 위해 프로그램의 복사할 영역을 지정한 영역 (코드 메모리라고도함)
     - 실제 존재하는 건 아님
     - 메모리에 구역을 나눠 놓은것


 A 프로그램을 실행하면 일단 프로그램 메모리에 A를 복사하고 실행함.
 B 프로그램을 실행하면 메모리에 B를 복사하고 실행함. 예전같으면 회로를 변경해서 B를 실행하게끔해야 했음a
  
 예시) 10 + 20 을 수행하는 프로그램  (실제 메모리에는 기계어로 올라가겠지만, 우리가 읽을수 있게 그냥 쉽게 표현한것)
 -> 10을 임의의 공간에 저장 -> PC :1
 -> 20을 임의의 공간에 저장 -> PC : 2
 -> 위의 두숫자를 더함 -> PC: 3
 -> 결과를 보여줌 -> PC:4
 이 4줄이 프로그램 메모리에 올라가는 것! -> 한줄 한줄 실행


 => 10과 20을 저장할 임의의 공간 과 결과를 저장할 공간이 필요함.
 => 데이터 메모리

 프로그램 메모리 / 데이터 메모리 가 메모리에 생김
 프로그램 메모리에서 프로그램을 가지고 있음
 프로그램이 실행될 때 필요한 데이터 메모리가 생겨남. => 실행 후 해지.(결과를 보여줄때 해지)
 프로그램은 다른 프로그램을 변경 가능.
 즉 프로그램메모리와 데이터메모리가 구분되서 실행됨.


 - 프로그램이 한줄 한줄 실행되는 원리에 대해 알아보자.
 CPU(연산처리 장치) - 보통 계산 / 많은 기능
 CPU에는 프로그램 카운터라는 PC(Program Counter) 존재 - 현재 실행되는 프로그램의 실행 위치를 나타냄 -> 카운터를 하나씩 올림으로 한줄한줄 실행..
 메모리 / CPU/ 프로그램

 클럭발생기 -> 시간을 발생한다. -> 수정(크리스탈)은 전기 받으면 진동 -> 사인파를 디지털 신호로 바꿈 -> 이 신호를 컴퓨터의 심장으로 사용
 클럭발생기에 라이징엣지?가 될때 한줄이 실행.

 기본 원리

 클럭발생기에서
 라이징 엣지 발생 PC: 0 -> 첫번째 줄 실행
 라이징 엣지 발생 PC: 1 -> 두번째 줄 실행
 라이징 엣지 발생 PC: 2 -> 세번째 줄 실행
 라이징 엣지 발생 PC: 3 -> 네번째 줄 실행
 라이징 엣지 발생 PC: 4 -> 프로그램 종료  데이터 메모리에 있던 공간 사라짐.
*/
